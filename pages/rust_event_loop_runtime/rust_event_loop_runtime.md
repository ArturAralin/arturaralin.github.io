# Event loop runtime на Rust
Лето. Пели птицы, солнце пробивалось сквозь щель между штор, ветер нежно окутывал снующий по улицам народ, а меня окутывала очередная волна желания программировать. Этот пост - результатом моей, на мой взгляд достаточно удачной, попытки написать простой рантайм на языке Rust.

## Мотивация и предостережение
Я сделал этот проект с целью собственного самообразования. Как известо лучший способ что-то понять - это объяснить это что-то кому-нибудь. Посему, это не инструкция, не туториал и не образец того как делать рантайм. Если вы находитесь в поисках рантайма для Rust то есть https://tokio.rs/ и https://async.rs/.

## Архитектура
Я много лет пишу на nodejs и мук выбора архитектуры я не испытывал. Event loop, она же реализация кооперативной многозадачности, на мой взгляд максимально простая и понятная архитектура.

### В общих чертах
Идея архитектуры заключается в том, что у нас есть бесконечный цикл и очередь задач.
Итерция цикла называется тиком (англ. tick). Задачи в очереди могут быть готовы к обработке или находиться в состоянии выполнения.
Задачи готовые к обработке во время тика обрабатываются последовательно в том порядке, в котром они попали в очередь обработки.

В псевдокоде выглядит примерно так
```
tasks_queue = queue()

loop {
  for task in get_ready_to_handle(tasks_queue) {
    execute(task)
  }

  if is_empty(task_queue) {
    break
  }
}
```

### Я вам врал, все несколько сложнее
Одной очередью тут не обойтись. Их нужно две и еще табличка где мы будем хранить наши задачи.

## Основной цикл
Тут про логику обработки сообщений. Как доставать из очереди

## Особенности фьюч в расте
Тут про контекст и вейкеры 

## Шаренный контекст 
Тут почему Шаренный, зачем две очереди 

## Вэйкер
Шаренный контекст, запоминание id задачи, очередь готовых задач 

## schedule, который смотрит в глобальную переменную 

## примеры фьюч 

## конец
