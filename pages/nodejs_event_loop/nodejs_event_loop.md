# node event-loop для самых маленьких и тупых

Я у мамы стал совсем большой и дорос до того, что уже сам провожу технические собеседования по NodeJS.
Одним из важных факторов оценки знаний кандидата я считаю понимание прицнипов работы NodeJS. Ох, чего мне только там не рассказывали. Возможно, я уже услышал все комбинации слов: очередь, таска, промис и ивент луп.
В самом деле, концепция кооперативной многозадачности (aka event-loop) не очень проста, но в этом посте я постараюсь на пальцах объяснить общую идею того, как это работает.

# Код!

Имеется нехитрый обработчик http запросов, который для простоты понимания выполняется за 100 миллисекунд. Уточню, что я имею в виду то, что 100 миллисекунд это время от начала открытия сетевого соединения до момента закрытия этого соединения. `Db.getUserById` это запрос в базу данных, которая способна асинхронно обрабатывать запросы.

```javascript
const express = app();

app.get('/users/:id', async (req, res) => {
  const user = await Db.getUserById(req.params.id);

  res.json({ user });
});

express.listen(8080);
```

Клиентский тоже не хитрый. Функция `request` принимает идентификатор пользователя, делает http запрос и выводит на экран время, которое занял запрос.
Функция `test` запускает два запроса паралельно, дожидается ответа от обоих запросов и выводит время, которое заняли запросы.

```javascript
async function request(id) {
  const now = Date.now();

  const res = await fetch(`http://localhost:8080/users/${id}`);

  await res.text();

  const elapsed = Date.now() - now;

  console.log(`Request ${id} elapsed time: ${elapsed}`);
}

async function test() {
  const now = Date.now();

  await Promise.all([
    request(10),
    request(20),
  ]);

  const elapsed = Date.now() - now;

  console.log(`Total elapsed time: ${elapsed}`);
}

test();
```

# Вопросы!
* За какое время выполнится один запрос?
* За какое время выпонятся оба запроса?
* Почему так происходит?

# Аналогия и театр
Я бы мог устроить душный разгон про очереди, тики, микро и макро таски, колбеки и все прочее, но я приведу условный пример из жизни, а потом переложу его на те термины и процессы, которые происходят в NodeJs.

## Сюжет и действующие лица

Начальник отдела кадров - Сергей Базоданнов, его секретарь - Таня Ивентлуповой и два брата Реквестовы Петя и Ваня.

Петя и Ваня Реквестовы хотят устроиться в компанию. Они заполнили свои анкеты и отправились лично отнести их в компанию.

## Сцена первая. Подача документов

В компании Петю и Ваню отправили к секретарю - Тане Ивентлуповой. Таня, в свойственной ей манере, увидев перед собой двух ярых кандидатов попросила встать их в очередь потому, что она одна и не может проверить и принять две анкеты одновременно. Петя и Ваня, не смотря на то, что пришли одовременно выстроились в очередь и по очереди отдают свои анкеты Тане. Таня в порядке очереди приняла анкеты, завела себе в ежедневнике задачи и сказала Пете и Ване, что сделает колбек (она так перезвонить называет), когда начальник посмотрим анкеты. Радостные Петя и Ваня уходят домой ждать, когда Таня сделаем им колбек.

## Сцена вторая. Документы и начальник

Сергей Базоданнов - суровый начальник и просит не тревожить его просто так, поэтому он попросил Таню отдавтаь документы ему не напрямую, а класть их в специальное место. Таня Ивентлупова исполнительная и никогда не тревожит его, а относит всякие бумажки и забирает подписанные каждый в определенные этапы тика. Тиком Таня называет цикл своего рабочего дня, одним из этапов, которого - это поход в кабинет начальника для того, чтобы оставить ему новые документы и забрать уже подписанные. Вот так вот, во время очередного тика, Таня приняла еще несколько бумажек и пошла к начальнику в кабинет отдать собранные ею за время тика документы. Каждый документ она подписала номером задачи из своего ежедневника.

## Сцена третья. Колбеки

Начальник Сергей посмотрел анкеты Пети и Вани, принял решение, что берет обоих, написал что-то на анкетах и положил их в папку, которую позже заберет Таня. Таня, следуя своему распорядку дня в виде так называемого ею тика, забрала бумажки, пришла на свое рабочее место и стала разбирать взятые ею документы, сверяясь со своим ежедневником. Дошла очередь и до анкет Пети и Вани. Таня, как и обещала, сделала колбек к каждому из кандидатов и пригласила забрать их свои анкеты с резолюциями начальника. Петя и Ваня Реквестовы на радостях прибежали в компанию, в порядке очереди забрали свои анкеты, после чего радостные пошли смотреть, что им написал Сергей на анкетах.

# Анализ спектакля
Начальник Сергей Базоданнов - это наша база данных, которая работает

Петя и Ваня Реквестовы - это наши запросы. Каждый из запросов сам по себе является по настоящему асинхронным и независимым так же как и Петя с Ваней.

Таня Ивентлупова - это наш NodeJS, в основе которого лежит архитектура event-loop. Сам по себе NodeJS работает синхронно, поэтому и все входящие асинхронные запросы он обрабатывает сихнронно, в том порядке, в котором они пришли. Именно из-за этого Таня просила выстроиться в очередь Петю и Ваню т.к. параллельно она не может обрабатывать их анкеты. Более того, чтобы эффективно использовать свое время Таня как и event-loop имеет четкий распорядок дня в виде последовательности действий, которые называются тиком. А самое главное и тут то, что Таня обрабатывает свои задачи порциями в том числе и взаимоействие со своим начальником. А могла бы кажду анкету носить сразу к начальнику, заставив ждать всю очередь, пока она сходит к начальнику, получит решение от начальника и передаст его тому, кто исходно принес анкету.

# Код! Снова код!

Теперь посмотрим на код через призму наших персонажей и сцен. В семпле ниже перонаж Таня, олицетворяющая event-loop, сокрыта от нас и действует неявно, но я постараюсь подсветить все моменты.

```javascript
const express = app();

app.get(
  '/users/:id',
  // Тут Таня приняла анкету на обработку
  // В данном случае обработка анкеты это три этапа
  // 1й - Таня вызвала человека из очереди. По большей части от сокрыт от нас
  // 2й - Таня получила анкету, записала задачу в свой ежедневник и пообещала перезвонить. Все эти действия происходят до await
  // 3й - Таня получила ответы от начальника и делает звоник (aka callbacks) всем, для кого ответ готов. Все действия после await
  async (req, res) => {
    // тут Таня записывает задачу в свой ежедневник о том, что она работает с какой-то анкетой
    // тут же Таня дает обещание (aka Promise) о том, что она оповестит об решении, когда оно поступит
    const form = await Database.reviewAndSignForm(req.params.id);

    // тут Таня уже всех оповестила (сделала колбеки) и отдает анкеты (вызов res.json)

    res.json({ form });
  }
);

express.listen(8080);
```

# Ответы и выводы

Если вы осилили мой графоманский спектакль и его анализ, то теперь можно получить ответы на поставленные вопросы

> За какое время выполнится один запрос?

За 100 миллисекунд. В реальности есть всякие разные издержки: сеть может работать не стабильно, задач в очереди может быть много и множество других факторов, но в наших лабораторных условиях будет 100 миллисекунд.

> За какое время выпонятся оба запроса?

Так же за 100 миллисекунд. Можно позанудничать на тему того, что задачи в очереди обрабатывались синхронно и суммарное время на обработку двух запросов будет чуть больше 100 миллисекунд.

> Почему так происходит?

Потому что NodeJS не блокирует event-loop во время обработки асинхронных задач, вместо этого он запускает асинхронную обработку, регистриурет её и продолжает обрабатывать задачи из тика. В свою очередь, когда асинхронная задача завершается она вызывает колбек, который ей выдал NodeJS и в ближайшем тике NodeJS возьмет задачу в обработку.
